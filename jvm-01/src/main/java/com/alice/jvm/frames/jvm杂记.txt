1. 类加载
	加载器类型 Bootstarp Loader  # 加载rt.jar
				Ext Loader   # exts 目录下的jar
				App Loader   # 加载classpath 下面的jar
				Custon Loader # 自定义加载器， 集成ClassLoader
		双亲委派机制： 简单的说就是， 类加载时通过由上之下的顺序加载，只有当父类无法加载的时候才会由子类加载
		这样设计的好处是，能保证一个类 在Jvm 中只有类的定义
	类加载过程
		1. 装载
			通过类的全限定名来将定位二进制流，并加载到JVM
			将类的元数据， 静态变量，常亮存入方法区
			在Heap 中创建一个java.lang.Class 对象，作为方法区数据的访问入口
		2. 链接
			验证：验证二进制流的合法性， 该二进制流的类型， 是否本版本可以解析等
			准备：为类的属性分配内存，并赋值默认值
			将字符引用转换为直接引用
		3. 初始化
			为类的属性赋值
2. 运行时数据区
	方法区，堆，虚拟机栈，本地方法栈，程序计数器	
	方法区:存放类定义文件， 运行时常量池，以及静态变量
	堆: 对象实例
	虚拟机栈： 线程运行的时候，分配，每个方法的调用，会生成一个栈帧
	程序计数器： 记录当前线程运行的虚拟机栈的行号，
3.  

	堆： 
			非堆
			堆：	
				老年代
				年轻代
					Eden 
					S1
					S0
					GC 先对Eden 区进行操作，如果Eden 区数据已满将进行一次Minor GC 将少量存活的对象放入S 区，
					如果S 区没有足够的空间存放，存活的对象， 则需要由Old 区分配空间 ，来进行担保
					为何Young 区要进行二次分区，设计成8:1:1的模型
					 前提是对象的创建以及销毁时一个很短的时间，也就是说，一次GC 以后将有很少的对象能存活下来，
					 这样的设计技能减少空间碎片， 又不至于，每次GC 都要扫描相对大的区域
						这里需要注意， 这种设计会有默认情况下， 10%的Young 空间浪费，就是一直为空的情况
						用少量的空间浪费，来减少Gc 还是比较合适的 
						核心:减少GC 次数， 简化空间碎片的处理复杂度，
						前提：对象的存活时间都会很短， 如果这个结论不成立的话， 我想JVM 会设计一个空间整理算法，来代替 811的算法来
					如果Old 区已满， 将会进行一次Major GC 
					
					当Young Old 区都满的时候会进行 Full GC 
					
				堆和方法区都会造成OOM 
				当本地方法栈栈帧过多的时候，会造成stackoverflow异常
				
			
			
			
			如果确定一个 对象为垃圾：
				可达性分析：基于GC root
				引用计数法：基于对象引用计数：缺点： 循环引用的问题